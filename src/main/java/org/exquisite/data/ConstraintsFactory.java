package org.exquisite.data;

import choco.Choco;
import choco.kernel.model.constraints.Constraint;
import choco.kernel.model.variables.integer.IntegerExpressionVariable;
import org.antlr.runtime.tree.CommonTree;
import org.exquisite.datamodel.ExquisiteEnums.ExampleConstraintValueTypes;
import org.exquisite.datamodel.ExcelExquisiteSession;
import org.exquisite.datamodel.ExquisiteValueBound;
import org.exquisite.datamodel.TestCase;
import org.exquisite.diagnosis.models.ConstraintsDiagnosisModel;
import org.exquisite.diagnosis.models.Example;
import org.exquisite.diagnosis.quickxplain.choco3.Choco3ConstraintFactory;
import org.exquisite.diagnosis.quickxplain.choco3.FormulaInfo;
import org.exquisite.parser.FormulaParser;
import org.exquisite.tools.Debug;
import org.exquisite.tools.IntegerUtilities;
import org.exquisite.tools.Utilities;

import java.util.*;

/**
 * This class is responsible for making and configuring the decision variables that are added to
 * the model of the constraint solver.<p>
 * Currently the constraint solver being used in Exquisite is Choco.
 * Due to various other limitations, only Integer variables are supported in Exquisite at the moment.
 */
public class ConstraintsFactory {

    public static final String WORKSHEET_PREFIX = "WS_1_";

    public static boolean PRUNE_IRRELEVANT_CELLS = true;

    /**
     * Example object to store any negative statements derived from test case data.
     */
    private Example<Constraint> negativeExample;

    /**
     * Example object to store any global positive statements derived from test case data.
     */
    private Example<Constraint> positiveExample;


    private ExcelExquisiteSession<Constraint> sessionData;

    // -- Following variables are used for collecting metrics about the constraints being constructed.
    /**
     * Returns the number for constraints LAST generated by a call to makeFormulae.
     */
    private int formulaConstraintCount;

    // --

    //TODO: add redundantConstraints property.
    /**
     * During example processing, work out which constraints are not needed.
     * Keep a collection then sort at the end of all example processing. The
     * result of the sort should be a set of constraints that are independent from
     * the the constraints that have been considered faulty...
     */


    /**
     * @param globalNegativeExample
     * @param globalPositiveExample
     */
    public ConstraintsFactory(Example<Constraint> globalNegativeExample, Example<Constraint> globalPositiveExample,
                              ExcelExquisiteSession<Constraint> sessionData) {
        this.negativeExample = globalNegativeExample;
        this.positiveExample = globalPositiveExample;
        this.sessionData = sessionData;
    }

    public ConstraintsFactory(ExcelExquisiteSession<Constraint> sessionData) {
        this();
        this.sessionData = sessionData;
    }

    public ConstraintsFactory() {
        this.negativeExample = new Example<>(true);
        this.positiveExample = new Example<>();
    }

    public Example<Constraint> getNegativeExample() {
        return this.negativeExample;
    }

    public Example<Constraint> getPositiveExample() {
        return this.positiveExample;
    }

    /**
     * Returns the number for constraints LAST generated by a call to makeFormulae.
     *
     * @return
     */
    public int getFormulaeConstraintsCount() {
        return formulaConstraintCount;
    }

    /**
     * Parses a formula from XML and adds it as a possibly faulty constraint to the tests.diagnosis model.
     *
     * @param formulae              XML node
     * @param model                 the Diagnosis model to populate
     * @param formulaParser         the parser
     * @param formulasOfConstraints the map to fill
     */
    public Dictionary<String, Constraint> makeFormulae(Dictionary<String, String> formulae,
                                                       FormulaParser formulaParser,
                                                       Dictionary<String, IntegerExpressionVariable> variablesMap,
                                                       ConstraintsDiagnosisModel<Constraint> diagnosisModel) {
        Dictionary<String, Constraint> result = new Hashtable<String, Constraint>();

        for (Enumeration<String> keys = formulae.keys(); keys.hasMoreElements(); ) {
            String cellReference = keys.nextElement();
            String formula = formulae.get(cellReference);
            formulaParser.parse(formula);
            String id = cellReference;// + " (" + formula + ")";

//			System.out.println("Formula: " + formula);

            formulaParser
                    .buildChocoStatements(id, cellReference, formulaParser.FormulaTree, variablesMap, WORKSHEET_PREFIX);
            Constraint newConstraint = formulaParser.constraints.get(id);
            result.put(id, newConstraint);
            // DJ: remember the formula info
            if (diagnosisModel != null) {
                CommonTree newTree = Choco3ConstraintFactory.copyTreeRecursive(formulaParser.FormulaTree);
                FormulaInfo finfo = new FormulaInfo(newTree, id, "=", formula);
                diagnosisModel.getFormulaInfoOfConstraints().put(newConstraint, finfo);

            }

        }
        formulaConstraintCount = result.size();
        return result;
    }

    /**
     * For compatibility purposes
     *
     * @param formulae
     * @param formulaParser
     * @param variablesMap
     * @return
     */
    public Dictionary<String, Constraint> makeFormulae(Dictionary<String, String> formulae,
                                                       FormulaParser formulaParser,
                                                       Dictionary<String, IntegerExpressionVariable> variablesMap) {
        return makeFormulae(formulae, formulaParser, variablesMap, null);

    }

    /**
     * Make a collection of constraints that specify the upper and lower bounds of a collection of variables.
     *
     * @param valueBounds  - a dictionary of value bounds. Key is on variable (cell) name or a range of cells the value bound should be applied to.
     * @param cellsInRange - any cell ranges that have been specified.
     * @return a collection of constraints representing upper and lower bounds for a given set of variables.
     */
    public Dictionary<String, Constraint> makeGlobalValueBoundsConstraints(
            Dictionary<String, ExquisiteValueBound> valueBounds, Dictionary<String, List<String>> cellsInRange,
            Dictionary<String, IntegerExpressionVariable> variablesMap) {

        Dictionary<String, Constraint> result = new Hashtable<String, Constraint>();

        for (Enumeration<String> keys = valueBounds.keys(); keys.hasMoreElements(); ) {
            String cellReference = keys.nextElement();
            ExquisiteValueBound valueBound = valueBounds.get(cellReference);
//			int min = (int)valueBound.getLower();
//			int max = (int)valueBound.getUpper();			

            if (Utilities.isCellRangeReference(cellReference)) {
                //add min & max constraint for each cell referenced in the range of cells.
                List<String> cells = cellsInRange.get(cellReference);
                Iterator<String> cellsIterator = cells.iterator();

                while (cellsIterator.hasNext()) {
                    String cellInRangeReference = cellsIterator.next();
                    Constraint constraint = makeGlobalValueBoundsConstraint(cellInRangeReference, valueBound,
                            variablesMap);
                    String constraintName = "globalValueBoundConstraint (" + valueBound
                            .getLower() + " < " + cellInRangeReference + " < " + valueBound.getUpper() + ")";
                    result.put(constraintName, constraint);
                }
            } else {
                //add min & max constraint for the one cell.
                Constraint constraint = makeGlobalValueBoundsConstraint(cellReference, valueBound, variablesMap);
                String constraintName = "globalValueBoundConstraint (" + valueBound
                        .getLower() + " < " + cellReference + " < " + valueBound.getUpper() + ")";
                result.put(constraintName, constraint);
            }
        }

        for (Enumeration<String> keys = result.keys(); keys.hasMoreElements(); ) {
            String key = keys.nextElement();
            this.positiveExample.addConstraint(result.get(key), key);
        }
        return result;
    }


    //makes value bound constraints from a test case to an example.
    private Dictionary<String, Constraint> makeValueBoundsConstraints(TestCase targetTestCase,
                                                                      Dictionary<String, IntegerExpressionVariable> variablesMap,
                                                                      Map<Constraint, FormulaInfo> formulaInfos) {
        Dictionary<String, Constraint> result = new Hashtable<String, Constraint>();
        Dictionary<String, ExquisiteValueBound> valueBounds = targetTestCase.getValueBounds();
        for (Enumeration<String> keys = valueBounds.keys(); keys.hasMoreElements(); ) {
            String cellReference = keys.nextElement();
            ExquisiteValueBound bounds = valueBounds.get(cellReference);

            int min = (int) bounds.getLower();
            int max = (int) bounds.getUpper();

            if (Utilities.isCellRangeReference(cellReference)) {
                List<String> cells = targetTestCase.getCellsInRange().get(cellReference);
//				// DJ: Can there be no cells in some range?
                if (cells == null) {
                    System.err.println("No cells in range: " + cellReference);

                }
                Iterator<String> cellsIterator = cells.iterator();

                while (cellsIterator.hasNext()) {
                    //fetch the variable from the collection
                    String cellInRangeReference = cellsIterator.next();
                    IntegerExpressionVariable cell = variablesMap.get(cellInRangeReference);

                    //Define "less than" constraint
                    String namePrefix = targetTestCase.getID();
                    String lessThanName = namePrefix + "_" + cellInRangeReference + "_leq (" + max + ")";
                    Constraint leq = Choco.leq(cell, max);
                    result.put(lessThanName, leq);
                    formulaInfos.put(leq, new FormulaInfo(null, cellInRangeReference, "<=", Integer.toString(max)));

                    //"greater than constraint
                    String greaterThanName = namePrefix + "_" + cellInRangeReference + "_geq (" + min + ")";
                    Constraint geq = Choco.geq(cell, min);
                    result.put(greaterThanName, geq);
                    formulaInfos.put(geq, new FormulaInfo(null, cellInRangeReference, ">=", Integer.toString(min)));
                }
            } else {
                IntegerExpressionVariable cell = variablesMap.get(cellReference);
                //Define "less than" constraint
                String namePrefix = targetTestCase.getID();
                String lessThanName = namePrefix + "_" + cellReference + "_leq (" + max + ")";
                Constraint leq = Choco.leq(cell, max);
                result.put(lessThanName, leq);
                formulaInfos.put(leq, new FormulaInfo(null, cellReference, "<=", Integer.toString(max)));

                //"greater than constraint
                String greaterThanName = namePrefix + "_" + cellReference + "_geq (" + min + ")";
                Constraint geq = Choco.geq(cell, min);
                result.put(greaterThanName, geq);
                formulaInfos.put(geq, new FormulaInfo(null, cellReference, ">=", Integer.toString(min)));
            }
        }

        return result;
    }

    /**
     * Makes a list of Example objects that are to be added to the DiagnosisModel object.
     *
     * @param testCases    - test case data from Exquisiste.
     * @param cellsInRange - any ranges of cells that have been defined by the user.
     * @param inputs       - the list of cell references that are inputs - we need this to filter the testCases.values property.
     * @return a List of Example objects.
     */
    public List<Example<Constraint>> makeExamplesFromTestCases(Dictionary<String, TestCase> testCases,
                                                               Dictionary<String, List<String>> cellsInRange,
                                                               Dictionary<String, IntegerExpressionVariable> variablesMap,
                                                               List<String> inputCells) {
        List<Example<Constraint>> result = new ArrayList<>();
        //process each test case individually...
        for (Enumeration<String> keys = testCases.keys(); keys.hasMoreElements(); ) {
            String key = keys.nextElement();
            TestCase testCase = testCases.get(key);
            //Debug.msg("\nProcessing test case '" + key + "'.");
            //Check the test cases' flag value
            switch (testCase.getFlag()) {
                //If a "Normal" test case is found then build a positive example from the data and
                //see if any negative test cases could be inferred from it.
                case Normal:
                    result.add(makeExamplesFromTestCase(testCase, cellsInRange, variablesMap, inputCells));
                    break;
                //The user has essentially specified a negative test case... therefore process accordingly.
                case EverythingWrong:
                    //TODO - this may be removed.
                    System.out.println("negative test case found!");
                    break;
                default:
                    System.err.println("test case flag value not recognised.");
            }
        }
        return result;
    }

    /**
     * Transforms TestCase data from ExquisiteAppXML TestCase into a (positive) Example object.<p>
     * Also derives any negative examples from the test case example and adds them to the negativeExample class member.
     *
     * @param targetTestCase
     * @param cellsInRange
     * @return (positive) Example object.
     */
    public Example<Constraint> makeExamplesFromTestCase(TestCase targetTestCase,
                                                        Dictionary<String, List<String>> cellsInRange,
                                                        Dictionary<String, IntegerExpressionVariable> variablesMap,
                                                        List<String> inputCells) {
        //the positive example to return.
        Example<Constraint> result = new Example<>();
        Dictionary<String, Constraint> testCaseValueBounds = makeValueBoundsConstraints(targetTestCase, variablesMap,
                result.choco3FormulaInfos);
        for (Enumeration<String> keys = testCaseValueBounds.keys(); keys.hasMoreElements(); ) {
            String key = keys.nextElement();
            Constraint c = testCaseValueBounds.get(key);
            result.addConstraint(c, key);
        }

        for (Enumeration<String> keys = targetTestCase.getValues().keys(); keys.hasMoreElements(); ) {
            String cellReference = keys.nextElement();
            if (inputCells.contains(cellReference)) {
                String cellValue = targetTestCase.getValues().get(cellReference);
                IntegerExpressionVariable variable = variablesMap.get(cellReference);
                int intValue = IntegerUtilities.parseToInt(cellValue);
                Constraint constraint = Choco.eq(variable, intValue);

                String constraintName = "inputValue " + cellReference + " = " + cellValue;

                // Remember the formula info
                FormulaInfo formulaInfo = new FormulaInfo(null, cellReference, "=", cellValue);
                result.choco3FormulaInfos.put(constraint, formulaInfo);

                result.addConstraint(constraint, constraintName, cellReference, ExampleConstraintValueTypes.InputValue);
            }
        }


        List<String> allParents = new ArrayList<String>();
        for (Enumeration<String> keys = targetTestCase.getFaultyValues().keys(); keys.hasMoreElements(); ) {
            String cellReference = keys.nextElement();
            String cellValue = targetTestCase.getFaultyValues().get(cellReference);
            IntegerExpressionVariable variable = variablesMap.get(cellReference);
            int intValue = IntegerUtilities.parseToInt(cellValue);
            String constraintName = "expectedValue " + cellReference + " = " + cellValue;

            Constraint constraint = Choco.eq(variable, intValue);
            result.addConstraint(constraint, constraintName, cellReference, ExampleConstraintValueTypes.ExpectedValue);

            // Remember the formula info
            FormulaInfo formulaInfo = new FormulaInfo(null, cellReference, "=", cellValue);
            result.choco3FormulaInfos.put(constraint, formulaInfo);


            if (PRUNE_IRRELEVANT_CELLS) {
                try {
                    for (String parent : this.sessionData.graph.getAllParents(cellReference)) {
                        if (!allParents.contains(parent)) {
                            allParents.add(parent);
                        }
                    }

                } catch (Exception e) {
                    e.printStackTrace();
                }

                if (!allParents.contains(cellReference)) {
                    allParents.add(cellReference);
                }
            }
        }

        if (PRUNE_IRRELEVANT_CELLS) {
            for (Enumeration<String> keys = this.sessionData.appXML.getFormulas().keys(); keys.hasMoreElements(); ) {
                String cellReference = keys.nextElement();
                if (!allParents.contains(cellReference)) {
                    ConstraintsDiagnosisModel<Constraint> diagnosisModel = (ConstraintsDiagnosisModel<Constraint>)
                            this.sessionData.getDiagnosisModel();
                    result.irrelevantConstraints.put(cellReference, Utilities
                            .getKeyByValue(diagnosisModel.getConstraintNames(), cellReference));
                }
            }
        }

        for (Enumeration<String> keys = targetTestCase.getCorrectValues().keys(); keys.hasMoreElements(); ) {
            String cellReference = keys.nextElement();
            String cellValue = targetTestCase.getCorrectValues().get(cellReference);
            IntegerExpressionVariable variable = variablesMap.get(cellReference);
            int intValue = IntegerUtilities.parseToInt(cellValue);
            Constraint constraint = Choco.eq(variable, intValue);
            String constraintName = "correctValue_" + cellReference + " = " + cellValue;
            result.addConstraint(constraint, constraintName, cellReference, ExampleConstraintValueTypes.CorrectValue);

            // Remember the formula info
            FormulaInfo formulaInfo = new FormulaInfo(null, cellReference, "=", cellValue);
            result.choco3FormulaInfos.put(constraint, formulaInfo);

        }

        Constraint negativeConstraint = makeNegativeExampleConstraints(targetTestCase.getValues(),
                targetTestCase.getFaultyValues(), variablesMap, inputCells);
        if (negativeConstraint != null) {
            String negativeConstraintName = "negativeConstraint_" + targetTestCase.getID();
            this.negativeExample.addConstraint(negativeConstraint, negativeConstraintName);
            Debug.msg("        " + negativeConstraintName + " added to global negative constraints collection.");
        } else {
            Debug.msg("        No negative example created for this test case due to insufficient data.");
        }
        return result;
    }

    /**
     * //NB we do not need to add the ! as this is done in ConstraintsQuickXPlain.generateConstraintFromNegExample()
     * Constructs a constraint of the form !(varA=x AND varB=y AND ...)
     * this constraint is then added to the negativeExample class member.
     *
     * @param testCaseValues - the values from the test case.
     * @param faultyValues   - values that were marked as faulty.
     * @param variablesMap   - the solver model IntegerExpressionVariables the constraint is to be built with.
     * @param inputCells     - a list of input cells
     * @return
     */
    private Constraint makeNegativeExampleConstraints(Dictionary<String, String> testCaseValues,
                                                      Dictionary<String, String> faultyValues,
                                                      Dictionary<String, IntegerExpressionVariable> variablesMap,
                                                      List<String> inputCells) {
        //The constraint to return.
        Constraint result = null;

        //Check if all input values and calculated values are present in order to make a negative test case.

        //The list of constraints that will comprise the constraint returned.
        List<Constraint> constraints = new ArrayList<Constraint>();

        //add input values
        for (Enumeration<String> keys = testCaseValues.keys(); keys.hasMoreElements(); ) {
            String cellReference = keys.nextElement();
            if (inputCells.contains(cellReference)) {
                String cellValue = testCaseValues.get(cellReference);
                IntegerExpressionVariable variable = variablesMap.get(cellReference);
                int intValue = IntegerUtilities.parseToInt(cellValue);
                constraints.add(Choco.eq(variable, intValue));
            }
        }

        //add faulty values
        for (Enumeration<String> keys = faultyValues.keys(); keys.hasMoreElements(); ) {
            String cellReference = keys.nextElement();
            String cellValue = testCaseValues.get(cellReference);
            if (cellValue == null) {
                Debug.msg(
                        "    Some values needed to construct a negative example are missing, therefore cancel negative example construction for this test case.");
                return null;
            }

            IntegerExpressionVariable variable = variablesMap.get(cellReference);
            int intValue = IntegerUtilities.parseToInt(cellValue);
            constraints.add(Choco.eq(variable, intValue));
        }

        //NB we do not need to add the ! as this is done in ConstraintsQuickXPlain.generateConstraintFromNegExample()
        //return a constraint of the form !(x=n AND y=n1 AND ...)
        result = makeChocoAndConstraint(constraints);
        return result;
    }

    /**
     * @param cellInRangeReference
     * @param bounds
     * @return A constraint of the form "i > min AND i < max"
     */
    public Constraint makeGlobalValueBoundsConstraint(String cellReference, ExquisiteValueBound bounds,
                                                      Dictionary<String, IntegerExpressionVariable> variablesMap) {
        IntegerExpressionVariable cell = variablesMap.get(cellReference);
        List<Constraint> constraints = new ArrayList<Constraint>();
        int min = (int) bounds.getLower();
        int max = (int) bounds.getUpper();
        //Define "less than" constraint
        constraints.add(Choco.leq(cell, max));
        //"greater than" constraint
        constraints.add(Choco.geq(cell, min));
        //return a single constraint by ANDing the two other constraints.
        return makeChocoAndConstraint(constraints);
    }

    /**
     * ANDs a list of constraints together.
     *
     * @param constraints e.g. constraint0, constraint1, constraint2
     * @return e.g. One constraint statement in the form of: constraint0 AND constraint1 AND constraint2 AND ... etc.
     */
    public Constraint makeChocoAndConstraint(List<Constraint> constraints) {
        Constraint[] constraintsArray = new Constraint[constraints.size()];
        int index = 0;
        for (Constraint constraint : constraints) {
            constraintsArray[index] = constraint;
            index++;
        }
        Constraint result = Choco.and(constraintsArray);
        return result;
    }
}
